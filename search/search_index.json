{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction A simple, easy to use, admin site designed to manage basic crud operations in starlette. We use the free version of font awesome so when overriding templates you can use any icon from there. Javascript is all written using alpine.js so there is no additional javascript files to worry about. The Vision Easy to use Easy to overwrite Are not forced to use a database Want pagination Want filtering Do not want this to get in the way when its not crud operations Getting Started - Installation This package has not been published to PyPI so you will need to install it from this repo . To do this simply run: pip install git+https://github.com/accent-starlette/starlette-admin.git@master#egg=starlette-admin The minimum Python requirement is 3.7.","title":"Introduction"},{"location":"#introduction","text":"A simple, easy to use, admin site designed to manage basic crud operations in starlette. We use the free version of font awesome so when overriding templates you can use any icon from there. Javascript is all written using alpine.js so there is no additional javascript files to worry about.","title":"Introduction"},{"location":"#the-vision","text":"Easy to use Easy to overwrite Are not forced to use a database Want pagination Want filtering Do not want this to get in the way when its not crud operations","title":"The Vision"},{"location":"#getting-started-installation","text":"This package has not been published to PyPI so you will need to install it from this repo . To do this simply run: pip install git+https://github.com/accent-starlette/starlette-admin.git@master#egg=starlette-admin The minimum Python requirement is 3.7.","title":"Getting Started - Installation"},{"location":"additional_views/","text":"Additional Views To add an additional view to an admin you will need to complete the following: Add the new view Provide the template loader to the config ( see templating ) Add the route name for easy access in the template Finally add the new route from starlette.authentication import has_required_scope from starlette.exceptions import HTTPException from starlette_core import config class PersonAdmin ( ... ): @classmethod async def some_view ( cls , request ): if not await cls . has_required_scope ( request ): raise HTTPException ( 403 ) instance = cls . get_object ( request ) context = cls . get_context ( request ) context . update ({ \"object\" : instance }) return config . templates . TemplateResponse ( \"some_view.html\" , context ) @classmethod def url_names ( cls ): names = super () . url_names () mount = cls . mount_name () names . update ({ \"some_view\" : f \" { cls . site . name } : { mount } _some_view\" , }) return names @classmethod def routes ( cls ): router = super () . routes () mount = cls . mount_name () router . add_route ( \"/ {id} /some-view\" , endpoint = cls . some_view , methods = [ \"GET\" ], name = f \" { mount } _some_view\" , ) return router You will need to show the link to the new view probably the list view or update view. You can do this by replacing a template. See templating . You can get the correct url via: < a href = \"{{ url_for(url_names.some_view, id=object.id) }}\" > Some View </ a > Example templates These can be found in the repo, for example the update.html .","title":"Additional Views"},{"location":"additional_views/#additional-views","text":"To add an additional view to an admin you will need to complete the following: Add the new view Provide the template loader to the config ( see templating ) Add the route name for easy access in the template Finally add the new route from starlette.authentication import has_required_scope from starlette.exceptions import HTTPException from starlette_core import config class PersonAdmin ( ... ): @classmethod async def some_view ( cls , request ): if not await cls . has_required_scope ( request ): raise HTTPException ( 403 ) instance = cls . get_object ( request ) context = cls . get_context ( request ) context . update ({ \"object\" : instance }) return config . templates . TemplateResponse ( \"some_view.html\" , context ) @classmethod def url_names ( cls ): names = super () . url_names () mount = cls . mount_name () names . update ({ \"some_view\" : f \" { cls . site . name } : { mount } _some_view\" , }) return names @classmethod def routes ( cls ): router = super () . routes () mount = cls . mount_name () router . add_route ( \"/ {id} /some-view\" , endpoint = cls . some_view , methods = [ \"GET\" ], name = f \" { mount } _some_view\" , ) return router You will need to show the link to the new view probably the list view or update view. You can do this by replacing a template. See templating . You can get the correct url via: < a href = \"{{ url_for(url_names.some_view, id=object.id) }}\" > Some View </ a >","title":"Additional Views"},{"location":"additional_views/#example-templates","text":"These can be found in the repo, for example the update.html .","title":"Example templates"},{"location":"admin_site/","text":"Admin Site The starlette_admin.site.AdminSite class inherits from starlette.routing.Router . So when used should be treated the same. The main differences here is that it includes additional methods such as: class AdminSite ( Router ): def register ( self , model_admin ) -> None : \"\"\" register an admin class on this site \"\"\" def registry ( self ) -> typing . List [ \"starlette_admin.admin.BaseAdmin\" ]: \"\"\" Returns a sorted list of `starlette_admin.admin.BaseAdmin` classes registered on this admin \"\"\" def register_widget ( self , widget ) -> None : \"\"\" register a widget on this site \"\"\" def widgets ( self ) -> typing . List [ \"starlette_admin.widgets.BaseWidget\" ]: \"\"\" Returns a list of `starlette_admin.widgets.BaseWidget` classes registered on this admin \"\"\" def get_logout_url ( self , request ) -> str : \"\"\" gets the logout url, by default will look for `auth:logout`. can be overridden if different. When set will display the logout icon \"\"\" def get_context ( self , request ) -> dict : \"\"\" gets the default context that all endpoints will share \"\"\" def is_auth_enabled ( self , request ) -> bool : \"\"\" attempts to see if request.user is set to be able to display the users display_name \"\"\" @property def base_url_name ( self ) -> str : \"\"\" returns the root url of the site ie `admin:root` \"\"\" async def root ( self , request ): \"\"\" the root view of the admin site \"\"\" Initializing There are two arguments here to take note of: def __init__ ( self , # name should be unique and a single word. It is used in routing # ie admin:root name : str , # the list of default permission scopes required # ie [\"authenticated\", \"admin\"] permission_scopes : typing . Sequence [ str ] = []) Registering Admin Classes A simple example, see BaseAdmin for further details on creating an admin class. class PersonAdmin ( BaseAdmin ): ... adminsite = AdminSite ( name = \"admin\" , permission_scopes = [ \"authenticated\" ]) adminsite . register ( PersonAdmin ) Registering Widgets See widgets .","title":"Admin Site"},{"location":"admin_site/#admin-site","text":"The starlette_admin.site.AdminSite class inherits from starlette.routing.Router . So when used should be treated the same. The main differences here is that it includes additional methods such as: class AdminSite ( Router ): def register ( self , model_admin ) -> None : \"\"\" register an admin class on this site \"\"\" def registry ( self ) -> typing . List [ \"starlette_admin.admin.BaseAdmin\" ]: \"\"\" Returns a sorted list of `starlette_admin.admin.BaseAdmin` classes registered on this admin \"\"\" def register_widget ( self , widget ) -> None : \"\"\" register a widget on this site \"\"\" def widgets ( self ) -> typing . List [ \"starlette_admin.widgets.BaseWidget\" ]: \"\"\" Returns a list of `starlette_admin.widgets.BaseWidget` classes registered on this admin \"\"\" def get_logout_url ( self , request ) -> str : \"\"\" gets the logout url, by default will look for `auth:logout`. can be overridden if different. When set will display the logout icon \"\"\" def get_context ( self , request ) -> dict : \"\"\" gets the default context that all endpoints will share \"\"\" def is_auth_enabled ( self , request ) -> bool : \"\"\" attempts to see if request.user is set to be able to display the users display_name \"\"\" @property def base_url_name ( self ) -> str : \"\"\" returns the root url of the site ie `admin:root` \"\"\" async def root ( self , request ): \"\"\" the root view of the admin site \"\"\"","title":"Admin Site"},{"location":"admin_site/#initializing","text":"There are two arguments here to take note of: def __init__ ( self , # name should be unique and a single word. It is used in routing # ie admin:root name : str , # the list of default permission scopes required # ie [\"authenticated\", \"admin\"] permission_scopes : typing . Sequence [ str ] = [])","title":"Initializing"},{"location":"admin_site/#registering-admin-classes","text":"A simple example, see BaseAdmin for further details on creating an admin class. class PersonAdmin ( BaseAdmin ): ... adminsite = AdminSite ( name = \"admin\" , permission_scopes = [ \"authenticated\" ]) adminsite . register ( PersonAdmin )","title":"Registering Admin Classes"},{"location":"admin_site/#registering-widgets","text":"See widgets .","title":"Registering Widgets"},{"location":"base_admin/","text":"Base Admin The base admin class found at starlette_admin.admin.BaseAdmin is a class used that all entities you need to add to the admin site will need to inherit from. It contains all the required attributes and methods required, such as list, create, edit, delete views as well as the templates used and routing. Example Here is an example of one that stores people in memory only. from starlette.exceptions import HTTPException from starlette_admin.admin import BaseAdmin from wtforms import fields , form , validators # the person object class Person ( dict ): def __str__ ( self ): # all objects should have a string method to reference # them in templates like {{ object }} return self [ \"name\" ] # create a list of people people = [ Person ({ \"id\" : id , \"name\" : f \"Person { id } \" }) for id in range ( 1 , 10 ) ] # create a form to validate the data and to use in the # create and edit views class PersonForm ( form . Form ): name = fields . TextField ( validators = [ validators . required ()]) # define the person admin class PersonAdmin ( BaseAdmin ): section_name = \"General\" collection_name = \"People\" routing_id_part = \"{id:int}\" list_field_names = [ \"name\" ] paginate_by = 10 order_enabled = True search_enabled = True create_form = PersonForm update_form = PersonForm delete_form = form . Form # all the below methods are already defined in the base admin class # and will raise exceptions of not completed @classmethod def get_list_objects ( cls , request ): \"\"\" this is used to get the main list results. in the base admin class it is responsible from sorting and filtering the results. The list view itself will paginate the results if cls.paginate_by has a value \"\"\" list_people = people # very basic search example search = request . query_params . get ( \"search\" , \"\" ) . strip () . lower () if search : list_people = list ( filter ( lambda obj : search in obj [ \"name\" ] . lower (), list_people ) ) # sort the results order_by = request . query_params . get ( \"order_by\" , \"name\" ) order_direction = request . query_params . get ( \"order_direction\" , \"asc\" ) list_people = sorted ( list_people , key = lambda k : k [ order_by ], reverse = order_direction == \"desc\" ) return list_people @classmethod def get_object ( cls , request ): \"\"\" get the id from the url and fint the person, raise a 404 if not found. this will be used to feed the edit and delete views \"\"\" id = int ( request . path_params [ \"id\" ]) try : return next ( o for o in people if o [ \"id\" ] == id ) except StopIteration : raise HTTPException ( 404 ) @classmethod async def do_create ( cls , form , request ): \"\"\" with the cleaned form and the request we can create our new person and add them to the people \"\"\" next_id = people [ - 1 ][ \"id\" ] + 1 if people else 1 new_person = Person ( form . data ) new_person [ \"id\" ] = next_id people . append ( new_person ) @classmethod async def do_update ( cls , instance , form , request ): \"\"\" here it includes an instance which is what the edit view got from get_object above. we update it and replace the person in people \"\"\" index = people . index ( instance ) for k , v in form . data . items (): instance [ k ] = v people [ index ] = instance @classmethod async def do_delete ( cls , instance , form , request ): \"\"\" remove the person from people \"\"\" index = people . index ( instance ) people . pop ( index ) Registering the Admin Once created register the admin on the admin site. adminsite = AdminSite ( name = \"admin\" ) adminsite . register ( PersonAdmin )","title":"Base Admin"},{"location":"base_admin/#base-admin","text":"The base admin class found at starlette_admin.admin.BaseAdmin is a class used that all entities you need to add to the admin site will need to inherit from. It contains all the required attributes and methods required, such as list, create, edit, delete views as well as the templates used and routing.","title":"Base Admin"},{"location":"base_admin/#example","text":"Here is an example of one that stores people in memory only. from starlette.exceptions import HTTPException from starlette_admin.admin import BaseAdmin from wtforms import fields , form , validators # the person object class Person ( dict ): def __str__ ( self ): # all objects should have a string method to reference # them in templates like {{ object }} return self [ \"name\" ] # create a list of people people = [ Person ({ \"id\" : id , \"name\" : f \"Person { id } \" }) for id in range ( 1 , 10 ) ] # create a form to validate the data and to use in the # create and edit views class PersonForm ( form . Form ): name = fields . TextField ( validators = [ validators . required ()]) # define the person admin class PersonAdmin ( BaseAdmin ): section_name = \"General\" collection_name = \"People\" routing_id_part = \"{id:int}\" list_field_names = [ \"name\" ] paginate_by = 10 order_enabled = True search_enabled = True create_form = PersonForm update_form = PersonForm delete_form = form . Form # all the below methods are already defined in the base admin class # and will raise exceptions of not completed @classmethod def get_list_objects ( cls , request ): \"\"\" this is used to get the main list results. in the base admin class it is responsible from sorting and filtering the results. The list view itself will paginate the results if cls.paginate_by has a value \"\"\" list_people = people # very basic search example search = request . query_params . get ( \"search\" , \"\" ) . strip () . lower () if search : list_people = list ( filter ( lambda obj : search in obj [ \"name\" ] . lower (), list_people ) ) # sort the results order_by = request . query_params . get ( \"order_by\" , \"name\" ) order_direction = request . query_params . get ( \"order_direction\" , \"asc\" ) list_people = sorted ( list_people , key = lambda k : k [ order_by ], reverse = order_direction == \"desc\" ) return list_people @classmethod def get_object ( cls , request ): \"\"\" get the id from the url and fint the person, raise a 404 if not found. this will be used to feed the edit and delete views \"\"\" id = int ( request . path_params [ \"id\" ]) try : return next ( o for o in people if o [ \"id\" ] == id ) except StopIteration : raise HTTPException ( 404 ) @classmethod async def do_create ( cls , form , request ): \"\"\" with the cleaned form and the request we can create our new person and add them to the people \"\"\" next_id = people [ - 1 ][ \"id\" ] + 1 if people else 1 new_person = Person ( form . data ) new_person [ \"id\" ] = next_id people . append ( new_person ) @classmethod async def do_update ( cls , instance , form , request ): \"\"\" here it includes an instance which is what the edit view got from get_object above. we update it and replace the person in people \"\"\" index = people . index ( instance ) for k , v in form . data . items (): instance [ k ] = v people [ index ] = instance @classmethod async def do_delete ( cls , instance , form , request ): \"\"\" remove the person from people \"\"\" index = people . index ( instance ) people . pop ( index )","title":"Example"},{"location":"base_admin/#registering-the-admin","text":"Once created register the admin on the admin site. adminsite = AdminSite ( name = \"admin\" ) adminsite . register ( PersonAdmin )","title":"Registering the Admin"},{"location":"basics/","text":"The Basics Once installed, getting an empty admin site shell up is simple. from starlette.applications import Starlette from starlette.middleware.sessions import SessionMiddleware from starlette.staticfiles import StaticFiles from starlette_admin.site import AdminSite # create our admin app adminsite = AdminSite ( name = \"admin\" ) # create our starlette app app = Starlette () # mount the admin site to /admin app . mount ( path = \"/admin\" , app = adminsite , name = adminsite . name ) # mount the static files app, this will load js and css from `starlette_admin` app . mount ( path = \"/static\" , app = StaticFiles ( directory = \"static\" , packages = [ \"starlette_admin\" ]), name = \"static\" ) # add session middleware, this is the min requirement as messages are used # like \"Saved successfully\" app . add_middleware ( SessionMiddleware , secret_key = \"secret\" ) This will allow you to go to /admin in your browser where you will see the basic site operational.","title":"The Basics"},{"location":"basics/#the-basics","text":"Once installed, getting an empty admin site shell up is simple. from starlette.applications import Starlette from starlette.middleware.sessions import SessionMiddleware from starlette.staticfiles import StaticFiles from starlette_admin.site import AdminSite # create our admin app adminsite = AdminSite ( name = \"admin\" ) # create our starlette app app = Starlette () # mount the admin site to /admin app . mount ( path = \"/admin\" , app = adminsite , name = adminsite . name ) # mount the static files app, this will load js and css from `starlette_admin` app . mount ( path = \"/static\" , app = StaticFiles ( directory = \"static\" , packages = [ \"starlette_admin\" ]), name = \"static\" ) # add session middleware, this is the min requirement as messages are used # like \"Saved successfully\" app . add_middleware ( SessionMiddleware , secret_key = \"secret\" ) This will allow you to go to /admin in your browser where you will see the basic site operational.","title":"The Basics"},{"location":"forms/","text":"Form Fields & Widgets We have created a few form fields and widgets as defined below. Fields There are additional form fields created for you to use. JSONField The json field is a simple field that validates the data and raises a form error if its not valid json. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = admin_fields . JSONField ( default = [] ) TagsField The tags field is a simple fields that allows you to enter multiple tags. The form.field.data will be a python list of strings. This inherits from starlette_admin.forms.fields.JSONField . from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = admin_fields . TagsField ( default = [] ) Widgets There are additional form field widgets created for you to use. CheckboxInput The checkbox widget just carries some simple styling for a more consistent look. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . BooleanField ( widget = admin_widgets . CheckboxInput (), ) and to use as a list of multiple from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . SelectMultipleField ( choices = ( ( \"One\" , \"One\" ), ( \"Two\" , \"Two\" ), ( \"Three\" , \"Three\" ), ( \"Four\" , \"Four\" ), ( \"Five\" , \"Five\" ), ), widget = widgets . ListWidget ( prefix_label = False ), option_widget = admin_widgets . CheckboxInput (), ) FileInput The file input has been hidden and replaced to look more like a form field. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . FileField ( widget = admin_widgets . FileInput () ) HorizontalSelect The horizontal select widget is to be used as a replacement for a multiple select field. This is for a more user friendly experience. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . SelectMultipleField ( choices = ( ( \"One\" , \"One\" ), ( \"Two\" , \"Two\" ), ( \"Three\" , \"Three\" ), ( \"Four\" , \"Four\" ), ( \"Five\" , \"Five\" ), ), widget = admin_widgets . HorizontalSelect (), ) PasswordInput The password input widget has an icon added to allow visibility of the password the user has typed. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . PasswordField ( widget = admin_widgets . PasswordInput (), ) RadioInput The radio widget just carries some simple styling for a more consistent look. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . RadioField ( choices = ( ( \"One\" , \"One\" ), ( \"Two\" , \"Two\" ), ( \"Three\" , \"Three\" ), ( \"Four\" , \"Four\" ), ( \"Five\" , \"Five\" ), ), option_widget = admin_widgets . RadioInput (), ) Select The select widget just carries some simple styling for a more consistent look. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . SelectField ( choices = ( ( \"\" , \"Please Select..\" ), ( \"Male\" , \"Male\" ), ( \"Female\" , \"Female\" ), ), widget = admin_widgets . Select (), )","title":"Form Fields & Widgets"},{"location":"forms/#form-fields-widgets","text":"We have created a few form fields and widgets as defined below.","title":"Form Fields &amp; Widgets"},{"location":"forms/#fields","text":"There are additional form fields created for you to use.","title":"Fields"},{"location":"forms/#jsonfield","text":"The json field is a simple field that validates the data and raises a form error if its not valid json. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = admin_fields . JSONField ( default = [] )","title":"JSONField"},{"location":"forms/#tagsfield","text":"The tags field is a simple fields that allows you to enter multiple tags. The form.field.data will be a python list of strings. This inherits from starlette_admin.forms.fields.JSONField . from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = admin_fields . TagsField ( default = [] )","title":"TagsField"},{"location":"forms/#widgets","text":"There are additional form field widgets created for you to use.","title":"Widgets"},{"location":"forms/#checkboxinput","text":"The checkbox widget just carries some simple styling for a more consistent look. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . BooleanField ( widget = admin_widgets . CheckboxInput (), ) and to use as a list of multiple from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . SelectMultipleField ( choices = ( ( \"One\" , \"One\" ), ( \"Two\" , \"Two\" ), ( \"Three\" , \"Three\" ), ( \"Four\" , \"Four\" ), ( \"Five\" , \"Five\" ), ), widget = widgets . ListWidget ( prefix_label = False ), option_widget = admin_widgets . CheckboxInput (), )","title":"CheckboxInput"},{"location":"forms/#fileinput","text":"The file input has been hidden and replaced to look more like a form field. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . FileField ( widget = admin_widgets . FileInput () )","title":"FileInput"},{"location":"forms/#horizontalselect","text":"The horizontal select widget is to be used as a replacement for a multiple select field. This is for a more user friendly experience. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . SelectMultipleField ( choices = ( ( \"One\" , \"One\" ), ( \"Two\" , \"Two\" ), ( \"Three\" , \"Three\" ), ( \"Four\" , \"Four\" ), ( \"Five\" , \"Five\" ), ), widget = admin_widgets . HorizontalSelect (), )","title":"HorizontalSelect"},{"location":"forms/#passwordinput","text":"The password input widget has an icon added to allow visibility of the password the user has typed. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . PasswordField ( widget = admin_widgets . PasswordInput (), )","title":"PasswordInput"},{"location":"forms/#radioinput","text":"The radio widget just carries some simple styling for a more consistent look. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . RadioField ( choices = ( ( \"One\" , \"One\" ), ( \"Two\" , \"Two\" ), ( \"Three\" , \"Three\" ), ( \"Four\" , \"Four\" ), ( \"Five\" , \"Five\" ), ), option_widget = admin_widgets . RadioInput (), )","title":"RadioInput"},{"location":"forms/#select","text":"The select widget just carries some simple styling for a more consistent look. from wtforms import fields , form , widget from starlette_admin.forms import fields as admin_fields from starlette_admin.forms import widgets as admin_widgets class MyForm ( form . Form ): field = fields . SelectField ( choices = ( ( \"\" , \"Please Select..\" ), ( \"Male\" , \"Male\" ), ( \"Female\" , \"Female\" ), ), widget = admin_widgets . Select (), )","title":"Select"},{"location":"model_admin/","text":"Model Admin Using the ModelAdmin This class assumes that you are using the database functionality within starlette_core and that your tables inherit from its Base class. See docs . The model admin class found at starlette_admin.admin.ModelAdmin is a class you can use when the entities are that of a SQLAlchemy table. It inherits the BaseAdmin and provides basic functionality for most of the core methods. such as: get_list_objects get_object do_create do_delete do_update As well as additional methods for: get_default_ordering get_ordered_results On the most part these will usually be enough but can be overritten when required. Example Below is an example of a SQLAlchemy table derived from the starlette_core.database.Base class, with a wtforms_alchemy.ModelForm for it's validation. Pagination is handled within the list endpoint. import sqlalchemy as sa from sqlalchemy import orm from starlette_admin.admin import ModelAdmin from starlette_core.database import Base , Session from wtforms_alchemy import ModelForm class Person ( Base ): name = sa . Column ( sa . String (), nullable = False , unique = True ) def __str__ ( self ): return self . name class PersonForm ( ModelForm ): class Meta : model = Person @classmethod def get_session ( cls ): return Session () class PersonAdmin ( ModelAdmin ): section_name = \"General\" collection_name = \"People\" model_class = Person list_field_names = [ \"name\" ] paginate_by = 10 order_enabled = True search_enabled = True create_form = PersonForm update_form = PersonForm delete_form = form . Form @classmethod def get_default_ordering ( cls , qs : orm . Query ) -> orm . Query : \"\"\" the default ordering of the list \"\"\" return qs . order_by ( \"name\" ) @classmethod def get_search_results ( cls , qs : orm . Query , term : str ) -> orm . Query : \"\"\" filter the qs from the search term \"\"\" return qs . filter ( Person . name . ilike ( f \"% { term } %\" ) Registering the Admin Once created register the admin on the admin site. adminsite = AdminSite ( name = \"admin\" ) adminsite . register ( PersonAdmin )","title":"Model Admin"},{"location":"model_admin/#model-admin","text":"Using the ModelAdmin This class assumes that you are using the database functionality within starlette_core and that your tables inherit from its Base class. See docs . The model admin class found at starlette_admin.admin.ModelAdmin is a class you can use when the entities are that of a SQLAlchemy table. It inherits the BaseAdmin and provides basic functionality for most of the core methods. such as: get_list_objects get_object do_create do_delete do_update As well as additional methods for: get_default_ordering get_ordered_results On the most part these will usually be enough but can be overritten when required.","title":"Model Admin"},{"location":"model_admin/#example","text":"Below is an example of a SQLAlchemy table derived from the starlette_core.database.Base class, with a wtforms_alchemy.ModelForm for it's validation. Pagination is handled within the list endpoint. import sqlalchemy as sa from sqlalchemy import orm from starlette_admin.admin import ModelAdmin from starlette_core.database import Base , Session from wtforms_alchemy import ModelForm class Person ( Base ): name = sa . Column ( sa . String (), nullable = False , unique = True ) def __str__ ( self ): return self . name class PersonForm ( ModelForm ): class Meta : model = Person @classmethod def get_session ( cls ): return Session () class PersonAdmin ( ModelAdmin ): section_name = \"General\" collection_name = \"People\" model_class = Person list_field_names = [ \"name\" ] paginate_by = 10 order_enabled = True search_enabled = True create_form = PersonForm update_form = PersonForm delete_form = form . Form @classmethod def get_default_ordering ( cls , qs : orm . Query ) -> orm . Query : \"\"\" the default ordering of the list \"\"\" return qs . order_by ( \"name\" ) @classmethod def get_search_results ( cls , qs : orm . Query , term : str ) -> orm . Query : \"\"\" filter the qs from the search term \"\"\" return qs . filter ( Person . name . ilike ( f \"% { term } %\" )","title":"Example"},{"location":"model_admin/#registering-the-admin","text":"Once created register the admin on the admin site. adminsite = AdminSite ( name = \"admin\" ) adminsite . register ( PersonAdmin )","title":"Registering the Admin"},{"location":"permissions/","text":"Permissions Assuming you want to lock down the admin site to only allow authenticated users access to it. In starlette there is an AuthenticationMiddleware that handles authentication and permissions. The below is an example of a dummy user auth backend that simulates a logged-in user. from starlette.authentication import AuthCredentials , AuthenticationBackend , SimpleUser from starlette.middleware.authentication import AuthenticationMiddleware # change our adminsite to require the permission_scopes of \"authenticated\" and \"admin\" adminsite = AdminSite ( name = \"admin\" , permission_scopes = [ \"authenticated\" , \"admin\" ]) # define our example auth backend class DummyAuthBackend ( AuthenticationBackend ): async def authenticate ( self , request ): # to simulate not logged in, just return out of this function return AuthCredentials ([ \"authenticated\" , \"admin\" ]), SimpleUser ( \"John Smith\" ) # add the auth middleware app . add_middleware ( AuthenticationMiddleware , backend = DummyAuthBackend ()) Now when you refresh the site, John Smith's name will appear and only authenticate admin users will be allowed in. Reality Check In reality you wont be using a dummy auth backend, this is only an example.","title":"Permissions"},{"location":"permissions/#permissions","text":"Assuming you want to lock down the admin site to only allow authenticated users access to it. In starlette there is an AuthenticationMiddleware that handles authentication and permissions. The below is an example of a dummy user auth backend that simulates a logged-in user. from starlette.authentication import AuthCredentials , AuthenticationBackend , SimpleUser from starlette.middleware.authentication import AuthenticationMiddleware # change our adminsite to require the permission_scopes of \"authenticated\" and \"admin\" adminsite = AdminSite ( name = \"admin\" , permission_scopes = [ \"authenticated\" , \"admin\" ]) # define our example auth backend class DummyAuthBackend ( AuthenticationBackend ): async def authenticate ( self , request ): # to simulate not logged in, just return out of this function return AuthCredentials ([ \"authenticated\" , \"admin\" ]), SimpleUser ( \"John Smith\" ) # add the auth middleware app . add_middleware ( AuthenticationMiddleware , backend = DummyAuthBackend ()) Now when you refresh the site, John Smith's name will appear and only authenticate admin users will be allowed in.","title":"Permissions"},{"location":"permissions/#reality-check","text":"In reality you wont be using a dummy auth backend, this is only an example.","title":"Reality Check"},{"location":"screenshots/","text":"Screenshots","title":"Screenshots"},{"location":"screenshots/#screenshots","text":"","title":"Screenshots"},{"location":"templating/","text":"Templating If you need to replace any templates you can. Assuming you have a template you want to use for your PersonAdmin.list_view . This can be achieved by setting: class PersonAdmin ( ... ): ... create_template : str = \"starlette_admin/create.html\" # the default delete_template : str = \"starlette_admin/delete.html\" # the default list_template : str = \"my_admin/list.html\" update_template : str = \"starlette_admin/update.html\" # the default Also you will need to pass to starlette_admin your Jinja2Templates loader. import jinja2 from starlette_admin import config as admin_config from starlette_core.templating import Jinja2Templates templates = Jinja2Templates ( loader = jinja2 . ChoiceLoader ( [ jinja2 . FileSystemLoader ( \"templates\" ), jinja2 . PackageLoader ( \"starlette_admin\" , \"templates\" ), ] ) ) admin_config . templates = templates app = Starlette () All templates loaded in the admin site from the config that by default will load from it's own package. The above will include the templates directory in your own project. Using starlette-auth This package also includes a set of templates required for when you are using the starlette-auth package which are located here . Set the auth config to the templates var from above: from starlette_auth import config as auth_config auth_config . templates = templates and set a few env variables to tell starlette-auth what the paths are to the templates: CHANGE_PW_TEMPLATE = \"starlette_admin/auth/change_password.html\" LOGIN_TEMPLATE = \"starlette_admin/auth/login.html\" RESET_PW_TEMPLATE = \"starlette_admin/auth/reset_password.html\" RESET_PW_DONE_TEMPLATE = \"starlette_admin/auth/reset_password_done.html\" RESET_PW_CONFIRM_TEMPLATE = \"starlette_admin/auth/reset_password_confirm.html\" RESET_PW_COMPLETE_TEMPLATE = \"starlette_admin/auth/reset_password_complete.html\" RESET_PW_EMAIL_SUBJECT_TEMPLATE = \"starlette_admin/auth/password_reset_subject.txt\" RESET_PW_EMAIL_TEMPLATE = \"starlette_admin/auth/password_reset_body.txt\"","title":"Templating"},{"location":"templating/#templating","text":"If you need to replace any templates you can. Assuming you have a template you want to use for your PersonAdmin.list_view . This can be achieved by setting: class PersonAdmin ( ... ): ... create_template : str = \"starlette_admin/create.html\" # the default delete_template : str = \"starlette_admin/delete.html\" # the default list_template : str = \"my_admin/list.html\" update_template : str = \"starlette_admin/update.html\" # the default Also you will need to pass to starlette_admin your Jinja2Templates loader. import jinja2 from starlette_admin import config as admin_config from starlette_core.templating import Jinja2Templates templates = Jinja2Templates ( loader = jinja2 . ChoiceLoader ( [ jinja2 . FileSystemLoader ( \"templates\" ), jinja2 . PackageLoader ( \"starlette_admin\" , \"templates\" ), ] ) ) admin_config . templates = templates app = Starlette () All templates loaded in the admin site from the config that by default will load from it's own package. The above will include the templates directory in your own project.","title":"Templating"},{"location":"templating/#using-starlette-auth","text":"This package also includes a set of templates required for when you are using the starlette-auth package which are located here . Set the auth config to the templates var from above: from starlette_auth import config as auth_config auth_config . templates = templates and set a few env variables to tell starlette-auth what the paths are to the templates: CHANGE_PW_TEMPLATE = \"starlette_admin/auth/change_password.html\" LOGIN_TEMPLATE = \"starlette_admin/auth/login.html\" RESET_PW_TEMPLATE = \"starlette_admin/auth/reset_password.html\" RESET_PW_DONE_TEMPLATE = \"starlette_admin/auth/reset_password_done.html\" RESET_PW_CONFIRM_TEMPLATE = \"starlette_admin/auth/reset_password_confirm.html\" RESET_PW_COMPLETE_TEMPLATE = \"starlette_admin/auth/reset_password_complete.html\" RESET_PW_EMAIL_SUBJECT_TEMPLATE = \"starlette_admin/auth/password_reset_subject.txt\" RESET_PW_EMAIL_TEMPLATE = \"starlette_admin/auth/password_reset_body.txt\"","title":"Using starlette-auth"},{"location":"widgets/","text":"Widgets Widgets can be added to the root page. Widgets are simply a class that has a context and a render method. class BaseWidget : template = \"starlette_admin/partials/widget.html\" def get_context ( self ): return { \"icon\" : \"fa fa-cog\" , \"value\" : 0 , \"text\" : \"Some text\" , \"description\" : \"Some useful description\" , } def render ( self ): template = config . templates . get_template ( self . template ) return template . render ( self . get_context ()) @property def html ( self ): return Markup ( self . render ()) The idea here is to inherit from BaseWidget and return the required context to render the template. In the below example we are using alpine.js to change the widgets text to its description when you mouseover the widget. It also sets a muted class on the .text element. The default template is: < div class = \"widget\" x-data = \"{toggle: false, text: '{{ text }}', description: '{{ description }}'}\" @ mouseenter = \"toggle = true\" @ mouseleave = \"toggle = false\" > < div class = \"icon\" >< i class = \"{{ icon }}\" ></ i ></ div > < div class = \"content\" > < div class = \"value\" > {{ value }} </ div > < div class = \"text\" :class = \"{'muted': toggle}\" x-text = \"toggle ? description : text\" ></ div > </ div > </ div > Creating Your Own Widget The below is a widget that displays the current date. from datetime import datetime from starlette_admin.widgets import BaseWidget class Today ( BaseWidget ): def get_context ( self ): return { \"icon\" : \"fa fa-calendar\" , \"value\" : datetime . utcnow () . strftime ( \" %d %B %Y\" ), \"text\" : \"Today\" , \"description\" : \"The date as at UTC time\" } adminsite = AdminSite ( name = \"admin\" ) adminsite . register_widget ( Today ()) This will appear on the root page. The free version of font awesome is loaded in the template so you can use any icon class from there.","title":"Widgets"},{"location":"widgets/#widgets","text":"Widgets can be added to the root page. Widgets are simply a class that has a context and a render method. class BaseWidget : template = \"starlette_admin/partials/widget.html\" def get_context ( self ): return { \"icon\" : \"fa fa-cog\" , \"value\" : 0 , \"text\" : \"Some text\" , \"description\" : \"Some useful description\" , } def render ( self ): template = config . templates . get_template ( self . template ) return template . render ( self . get_context ()) @property def html ( self ): return Markup ( self . render ()) The idea here is to inherit from BaseWidget and return the required context to render the template. In the below example we are using alpine.js to change the widgets text to its description when you mouseover the widget. It also sets a muted class on the .text element. The default template is: < div class = \"widget\" x-data = \"{toggle: false, text: '{{ text }}', description: '{{ description }}'}\" @ mouseenter = \"toggle = true\" @ mouseleave = \"toggle = false\" > < div class = \"icon\" >< i class = \"{{ icon }}\" ></ i ></ div > < div class = \"content\" > < div class = \"value\" > {{ value }} </ div > < div class = \"text\" :class = \"{'muted': toggle}\" x-text = \"toggle ? description : text\" ></ div > </ div > </ div >","title":"Widgets"},{"location":"widgets/#creating-your-own-widget","text":"The below is a widget that displays the current date. from datetime import datetime from starlette_admin.widgets import BaseWidget class Today ( BaseWidget ): def get_context ( self ): return { \"icon\" : \"fa fa-calendar\" , \"value\" : datetime . utcnow () . strftime ( \" %d %B %Y\" ), \"text\" : \"Today\" , \"description\" : \"The date as at UTC time\" } adminsite = AdminSite ( name = \"admin\" ) adminsite . register_widget ( Today ()) This will appear on the root page. The free version of font awesome is loaded in the template so you can use any icon class from there.","title":"Creating Your Own Widget"}]}